; Reversible Memory Operations Example
; Demonstrates RISA memory operations with SDM (Software Defined Memory)

main:
    ; Create checkpoint - SDM will version memory pages
    CHECKPOINT start
    
    ; Initialize registers and memory address
    LI R0, 1000      ; Memory address
    LI R1, 42        ; Value to store
    LI R2, 0         ; Will hold old memory value
    
    ; Reversible store operation
    ; RSTORE preserves the old memory value
    RSTORE R0, R1, R2   ; Mem[1000] = 42, R2 = old Mem[1000]
    
    DEBUG After RSTORE - old value preserved in R2
    
    ; Prepare for memory swap
    LI R3, 99        ; New value for swap
    
    ; Memory-register swap (MSWAP)
    ; This atomically swaps register with memory
    MSWAP R0, R3     ; R3 = Mem[1000] (42), Mem[1000] = 99
    
    DEBUG After MSWAP - values exchanged
    
    ; Swap again to restore (MSWAP is self-inverse)
    MSWAP R0, R3     ; R3 = Mem[1000] (99), Mem[1000] = 42
    
    DEBUG After second MSWAP - original state restored
    
    ; Demonstrate reversible load
    LI R4, 77        ; Some value in R4
    LI R5, 0         ; Will hold old R4 value
    
    ; RLOAD preserves the old register value
    RLOAD R4, R0, R5  ; R4 = Mem[1000] (42), R5 = old R4 (77)
    
    DEBUG After RLOAD - old register value preserved in R5
    
    ; To reverse the load, swap the destination and old registers
    RLOAD R5, R0, R4  ; R5 = Mem[1000] (42), R4 = old R5 (77)
    
    DEBUG After reverse RLOAD - R4 restored to 77
    
    ; Complex memory pattern with multiple addresses
    LI R6, 2000      ; Second address
    LI R7, 100       ; Value for second location
    LI R8, 0         ; Temp for old values
    
    ; Store to multiple locations
    RSTORE R6, R7, R8    ; Mem[2000] = 100, R8 = old Mem[2000]
    
    ; Swap between memory locations using registers
    MSWAP R0, R7         ; R7 = Mem[1000] (42), Mem[1000] = 100
    MSWAP R6, R7         ; R7 = Mem[2000] (100), Mem[2000] = 42
    
    DEBUG After memory location swap
    
    ; Restore by swapping in reverse order
    MSWAP R6, R7         ; R7 = Mem[2000] (42), Mem[2000] = 100
    MSWAP R0, R7         ; R7 = Mem[1000] (100), Mem[1000] = 42
    
    DEBUG Memory locations restored
    
    ; Demonstrate SDM time-travel capability
    ; Uncomment to rewind and see SDM restore all memory states:
    ; REWIND start
    ; DEBUG After rewind - all memory restored by SDM!
    
    HALT

; Key differences with RISA + SDM:
; 1. RSTORE/RLOAD preserve old values - no information loss
; 2. MSWAP provides atomic memory-register exchange
; 3. SDM automatically versions memory pages for time-travel
; 4. No manual trail management needed
; 5. All operations have clear inverses