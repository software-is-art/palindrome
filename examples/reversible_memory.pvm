; Reversible Memory Operations Example
; Demonstrates memory operations that preserve information

main:
    ; Set up data segment
    CHECKPOINT start
    
    ; Initialize memory location with value
    LI R0, 1000      ; Address
    LI R1, 42        ; Value to store
    STORE R0, R1     ; Mem[1000] = 42
    
    ; Reversible memory swap
    ; MSWAP would swap register with memory
    ; Simulating: temp = Mem[addr]; Mem[addr] = reg; reg = temp
    
    LI R2, 99        ; New value
    LI R3, 0         ; Will hold old memory value
    
    DEBUG Before memory swap
    
    ; Simulate MSWAP R0, R2
    LOAD R3, R0      ; R3 = Mem[R0] (save old value)
    STORE R0, R2     ; Mem[R0] = R2
    PUSH R2          ; Save R2
    POP R2           ; This would be: R2 = R3 in real MSWAP
    PUSH R3
    POP R2           ; R2 now has old memory value
    
    DEBUG After memory swap - values exchanged
    
    ; Reverse the swap (MSWAP is self-inverse)
    LOAD R3, R0      ; R3 = Mem[R0]
    STORE R0, R2     ; Mem[R0] = R2  
    PUSH R2
    POP R2
    PUSH R3
    POP R2           ; R2 = R3
    
    DEBUG After reverse swap - original state restored
    
    ; Demonstrate reversible load
    ; RLOAD preserves the old register value
    
    LI R4, 77        ; Some value in R4
    LI R5, 0         ; Will hold old R4
    
    DEBUG Before reversible load
    
    ; Simulate RLOAD R4, R0, R5
    ; R4 = Mem[R0], R5 = old R4
    PUSH R4          ; Save old R4
    LOAD R4, R0      ; R4 = Mem[R0]
    POP R5           ; R5 = old R4
    
    DEBUG After reversible load - old value preserved in R5
    
    ; To reverse: RLOAD R5, R0, R4
    ; Which restores R4 to its old value
    PUSH R5          ; old becomes new
    PUSH R4          ; new becomes old
    POP R5
    POP R4
    
    DEBUG After reversal - R4 restored
    
    ; Rewind to show trail still works
    REWIND start
    
    DEBUG After rewind - everything restored
    
    HALT

; In a true reversible ISA:
;
; main:
;     LI R0, 1000       ; Address
;     LI R1, 42         ; Value
;     LI R2, 99         ; Another value
;     
;     RSTORE R0, R1, R3 ; Mem[R0] = R1, R3 = old Mem[R0]
;     
;     MSWAP R0, R2      ; Swap R2 with Mem[R0]
;     MSWAP R0, R2      ; Swap again (self-inverse)
;     
;     RLOAD R4, R0, R5  ; R4 = Mem[R0], R5 = old R4
;     RLOAD R5, R0, R4  ; Reverse the load
;     
;     HALT